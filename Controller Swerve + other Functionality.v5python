{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nLTMotor = Motor(Ports.PORT13, GearSetting.RATIO_6_1, False)\nLBMotor = Motor(Ports.PORT11, GearSetting.RATIO_6_1, False)\ndist1 = Distance(Ports.PORT12)\ncontroller_1 = Controller(PRIMARY)\nRTMotor = Motor(Ports.PORT18, GearSetting.RATIO_6_1, False)\nRBMotor = Motor(Ports.PORT20, GearSetting.RATIO_6_1, False)\ndist2 = Distance(Ports.PORT19)\nIntake = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nrobotGyro = Inertial(Ports.PORT17)\ndiscMotor = Motor(Ports.PORT6, GearSetting.RATIO_18_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# For debugging\n# brain.screen.clear_screen()\n# brain.screen.set_cursor(1,1)\n# brain.screen.print(turnSpeed)\n# brain.screen.set_cursor(2,1)\n# brain.screen.print(moveSpeed)\n\n#useful function\ndef CalcAngSpe(x,y, thresh = 0.05):\n    #deal with stick drift\n    if abs(x) < thresh:\n        x = 0\n    if abs(y) < thresh:\n        y = 0\n\n    moveDir = math.atan2(x, y) * 180 / math.pi\n    speed = (x**2 + y**2)**(1/2)\n\n    return moveDir, speed\n\n#define PID controller\nclass PIDController:\n    def __init__(self, kp, ki, kd, setpoint=0.0):\n        self.kp = kp  # Proportional gain\n        self.ki = ki  # Integral gain\n        self.kd = kd  # Derivative gain\n\n        self.prev_error = 0.0\n        self.integral = 0.0\n\n    def setPID(self, kp, ki, kd):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n\n    def update(self, error, dt):\n        self.integral += error * dt\n        derivative = (error - self.prev_error) / dt if dt > 0 else 0.0\n\n        output = (\n            self.kp * error +\n            self.ki * self.integral +\n            self.kd * derivative\n        )\n\n        self.prev_error = error\n        return output\n\n# Define swerve class\nclass SwerveModule:\n    setpoint = [0,0]\n    motor_to_ring = 15/150\n    ring_to_wheel = 136/24\n    motor_split = [0.5, 0.5]\n\n    def __init__(self, t_motor, b_motor, ir, pid_values, start_dir = 0):\n        self.t_motor = t_motor\n        self.b_motor = b_motor\n        self.ir = ir\n        self.start_dir = start_dir\n\n        self.t_motor.spin(FORWARD)\n        self.b_motor.spin(FORWARD)\n        \n        self.t_motor.set_velocity(0)\n        self.b_motor.set_velocity(0)\n\n        self.t_motor.set_max_torque(100, PERCENT)\n        self.t_motor.set_max_torque(100, PERCENT)\n\n        self.pid = PIDController(*pid_values)\n\n        self.isHomed = False\n\n    def Home(self):\n        self.isHomed = False\n\n        thresh = 30\n        p1, p2 = [0,0], [0,0]\n        correction = 80 #IR seems to be slightly offset causing an off center Home\n        \n        #So the wheel doesn't start triggered\n        if self.ir.object_distance(MM) < thresh:\n            self.SetModule(0, (12.5/self.motor_split[1]))\n            while self.ir.object_distance(MM) < thresh:\n                wait(0.05, SECONDS)\n            wait(0.5, SECONDS)\n\n        #Get First pos\n        self.SetModule(0, -(12.5/self.motor_split[1]))\n\n        while self.ir.object_distance(MM) >= (thresh-2):\n            wait(0.05, SECONDS)\n\n        p1 = [self.t_motor.position(DEGREES), self.b_motor.position(DEGREES)]\n\n        #Get Second Pos\n        while self.ir.object_distance(MM) < thresh:\n            wait(0.05, SECONDS)\n        p2 = [self.t_motor.position(DEGREES), self.b_motor.position(DEGREES)]\n\n        #determine which side of wheel we are on\n        diff = ((p1[0]-p2[0])+(p1[1]-p2[1]))/2\n        #Diff NoNubs ~ 400\n        #Diff WithNubs ~ 680\n        self.start_dir += 0 if (diff < 540) else 180\n\n        #Move to midpoint\n        self.SetModule(0, (12.5/self.motor_split[1]))\n        self.t_motor.spin_to_position((p1[0]+p2[0])/2 + correction, DEGREES)\n        self.b_motor.spin_to_position((p1[1]+p2[1])/2 + correction, DEGREES)\n\n        #stop and zero\n        self.t_motor.spin(FORWARD)\n        self.b_motor.spin(FORWARD)\n        self.SetModule(0, 0)\n        wait(1, SECONDS)\n        self.t_motor.set_position(self.start_dir / self.motor_to_ring, DEGREES)\n        self.b_motor.set_position(self.start_dir / self.motor_to_ring, DEGREES)\n\n        self.isHomed = True\n\n    def SetModule(self, moveSpeed, turnSpeed):\n        tSpeed = -self.motor_split[0]*moveSpeed + self.motor_split[1]*turnSpeed\n        bSpeed = self.motor_split[0]*moveSpeed + self.motor_split[1]*turnSpeed\n\n        #catch errors when attempting to set speed too high\n        if tSpeed > 100 or tSpeed < -100 or bSpeed > 100 or bSpeed < -100:\n            self.SetModule(0, 0)\n            raise Exception(\"Motor Speed Too High. Attempeted to run (\" + str(moveSpeed) + \",\" + str(turnSpeed) + \")\")\n            return\n\n        self.t_motor.set_velocity(tSpeed, PERCENT)\n        self.b_motor.set_velocity(bSpeed, PERCENT)\n        \n    def WheelAngle(self):\n        return (0.5 * (self.t_motor.position(DEGREES) + self.b_motor.position(DEGREES)) * self.motor_to_ring)\n\n    def MoveToSetpoint(self, setpoint, dt = 0.05):\n        move_speed = setpoint[0]\n\n        #calc turn speed\n        target_angle = setpoint[1]\n        current_angle = self.WheelAngle()%360 - 180\n        diff = target_angle - current_angle\n        \n        #Move the the shorter turn direction\n        if abs(diff) >= 180:\n            diff -= diff/abs(diff) * 360\n\n        #move to a position 180 off and flip direction\n        if abs(diff) >= 90:\n            diff -= diff/abs(diff) * 180\n            move_speed *= -1\n\n        #Control Turn\n        turn_speed = min(100, max(-100, self.pid.update(diff, dt)))\n\n        self.SetModule(move_speed, turn_speed)\n\nclass SwerveDrive:\n    modules = []\n    moduleLocs = []\n    movementCalcs = []\n    turnCalcs = []\n\n    maxTurn = 0.5\n    targetOrientation = 0\n    orientPID = PIDController(2,0,0.25)\n\n    allHomed = False\n    robotDir = 0\n    movementDir = 0\n\n    gyroDrift = 0\n    \n    def __init__(self, gyro):\n        #Set up gyro\n        gyro.calibrate()\n        while gyro.is_calibrating():\n            wait(0.05, SECONDS)\n        self.gyro = gyro\n\n        #Start a seperate update loop\n        Thread(self.update)\n\n    def AddModule(self, module, location):\n        self.modules.append(module)\n        self.moduleLocs.append(location)\n        self.allHomed = False\n\n    def Home(self):\n        self.allHomed = False\n\n        #exit if no modules to home\n        if len(self.modules) == 0: \n            return\n\n        #Run all homing sequences simultaneously\n        for module in self.modules:\n            Thread(module.Home)\n\n        wait(0.5,SECONDS)\n        #Vex Thread class that doesn't have the .join() Function\n        #This is my work around\n        isHomed = False\n        while not isHomed:\n            isHomed = True\n            for module in self.modules:\n                if not module.isHomed:\n                    isHomed = False\n\n        self.allHomed = True\n\n        brain.screen.print(\"Done Homing\")\n\n    def robotOrientation(self):\n        return self.gyroDrift + self.gyro.heading(DEGREES)\n\n    def calculateMovement(self, moveDir, speed, fieldOriented = True):\n        includeGyro = 1 if fieldOriented else 0\n\n        out = []\n        for module in self.modules:\n            out.append([speed, moveDir + self.gyro.heading(DEGREES) * includeGyro])\n\n        self.movementCalcs = out\n\n    def calculateTurn(self, turnSpeed):\n\n        out = []\n        for location in self.moduleLocs:\n            moduleDir = math.atan2(location[1], location[0]) * (180/math.pi)\n            moduleDir -= 90 + 90\n            out.append([turnSpeed, moduleDir])\n\n        self.turnCalcs = out\n\n    def SetRobotPID(self, values):\n        self.orientPID.setPID(*values)\n\n    def setRobotOrientation(self, target, magnitude):\n        #whether or not to update the target orientation\n        if magnitude > 1:\n            self.targetOrientation = target\n        \n        #PID to target orientation\n        diff = self.targetOrientation - self.robotOrientation()\n        diff = diff % 360\n        if diff >= 180:\n            diff -= 360\n\n        if abs(diff) < 2:\n            diff = 0\n        \n\n        turnSpeed = self.orientPID.update(diff, 0.05) #TODO create a global dt\n        turnSpeed = min(100, max(-100, turnSpeed))\n\n        self.calculateTurn(turnSpeed)\n\n    def update(self):\n        while True:\n            \n            #Draw Forward\n            cx = 250\n            cy = 125\n            rad = 100\n            ori = math.radians(self.robotOrientation())\n            brain.screen.clear_screen()\n            brain.screen.draw_line(cx, cy, cx-rad*math.sin(ori), cy-rad*math.cos(ori))\n\n            #Don't move modules if motors aren't  homed yet\n            wait(0.05, SECONDS)\n            if not self.allHomed:\n                continue\n\n            #Calculate movement\n            for module, mCalcs, tCalcs in zip(self.modules, self.movementCalcs, self.turnCalcs):\n\n                #Combine turn and move calculations\n                turnSpeed = self.maxTurn * tCalcs[0]\n                x = turnSpeed * math.cos((math.pi/180)*tCalcs[1])\n                y = turnSpeed * math.sin((math.pi/180)*tCalcs[1])\n\n                moveSpeed = (100 - abs(turnSpeed))/100 #run a variable split on movement\n                x += moveSpeed * mCalcs[0] * math.cos((math.pi/180)*mCalcs[1])\n                y += moveSpeed * mCalcs[0] * math.sin((math.pi/180)*mCalcs[1])\n\n                moduleDir = math.atan2(y, x) * (180/math.pi)\n                speed = (x**2 + y**2)**(1/2)\n\n                module.MoveToSetpoint([speed, moduleDir])\n            \n#Disc Grabbing\ndef DiscIntake():\n    discMotor.spin(FORWARD)\n\ndef DiscOutake():\n    discMotor.spin(REVERSE)\n    wait(0.5,SECONDS)\n    discMotor.stop()\n\nThread(DiscOutake)\ncontroller_1.buttonR1.pressed(DiscIntake)\ncontroller_1.buttonR2.pressed(DiscOutake)\n\n#Run Intake\nintake_speed = 100\ndef RunOuttake():\n    Intake.set_velocity(intake_speed,PERCENT)\n\ndef RunIntake():\n    Intake.set_velocity(-intake_speed,PERCENT)\n\nIntake.spin(FORWARD)\nRunIntake()\n\ncontroller_1.buttonL1.pressed(RunOuttake)\ncontroller_1.buttonL1.released(RunIntake)\n\n\n#Drive Train\nlModule = SwerveModule(LTMotor, LBMotor, dist1, pid_values = [4,0,0.2], start_dir = 0)\nrModule = SwerveModule(RTMotor, RBMotor, dist2, pid_values = [4,0,0.2], start_dir = 0)\n\ndriveTrain = SwerveDrive(robotGyro)\ndriveTrain.AddModule(lModule, [-1,-1])\ndriveTrain.AddModule(rModule, [1,-1])\n\ndriveTrain.Home()\n\ncontroller_1.buttonDown.pressed(driveTrain.Home)\nwait(0.5, SECONDS)\n\n# #Test PID Values #REMOVE_WHEN_DONE\n# testVals = [10,0,3]\n# def increaseP():\n#     testVals[0] += 0.5\n#     PrintPID()\n# def decreaseP():\n#     testVals[0] -= 0.5\n#     PrintPID()\n\n# def increaseD():\n#     testVals[2] += 0.5\n#     PrintPID()\n# def decreaseD():\n#     testVals[2] -= 0.5\n#     PrintPID()\n\n# def PrintPID():\n#     global testVals\n#     #TEST print pid values\n#     brain.screen.clear_screen()\n#     brain.screen.set_cursor(1,1)\n#     brain.screen.print(testVals)\n#     driveTrain.SetRobotPID(testVals)\n    \n# controller_1.buttonL1.pressed(increaseP)\n# controller_1.buttonL2.pressed(decreaseP)\n# controller_1.buttonR1.pressed(increaseD)\n# controller_1.buttonR2.pressed(decreaseD)\n\nwhile True:\n    #Movement\n    moveX = (-controller_1.axis4.position()/100)**3 * 100\n    moveY = (controller_1.axis3.position()/100)**3 * 100\n    moveDir, speed = CalcAngSpe(moveX, moveY, thresh = 0.15)\n    speed = min(100, max(speed, 0))\n    if controller_1.buttonB.pressing():\n        speed /= 4\n    driveTrain.calculateMovement(moveDir, speed, fieldOriented = True)\n\n    #Orientation\n    orientX = (controller_1.axis1.position()/100)**3 * 100\n    orientY = (controller_1.axis2.position()/100)**3 * 100\n    orientDir, mag = CalcAngSpe(orientX, orientY, thresh = 0.8)\n    driveTrain.setRobotOrientation(orientDir, mag)\n    \n    wait(0.05, SECONDS)","textLanguage":"python","robotConfig":[{"port":[13],"name":"LTMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[11],"name":"LBMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[12],"name":"dist1","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[18],"name":"RTMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[20],"name":"RBMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[19],"name":"dist2","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1],"name":"Intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[17],"name":"robotGyro","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[6],"name":"discMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22}],"slot":3,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}